import logging
import asyncio
from aiogram import Bot, Dispatcher, F, types
from aiogram.enums import ParseMode, ChatType
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.default import DefaultBotProperties
from aiogram.types import ChatPermissions, ReplyKeyboardMarkup, KeyboardButton
import random
import requests
import os
from functools import lru_cache

# –ë–∞–∑–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
TOKEN = os.environ['BOT_TOKEN']
ADMIN_IDS = tuple(int(id) for id in os.environ['ADMIN_IDS'].split(','))
GROUP_ID = int(os.environ['GROUP_ID'])
GROUP_LINK = os.environ['GROUP_LINK']
UNSPLASH_ACCESS_KEY = os.environ.get('UNSPLASH_ACCESS_KEY')

# –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = Bot(token=TOKEN, default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher(storage=MemoryStorage())

# –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
user_data = {}
message_counts = {}
MAX_MESSAGES = 5

# –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä
@lru_cache(maxsize=2)
def get_menu():
    return ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
        [KeyboardButton(text="–†–µ—Å—Ç"), KeyboardButton(text="–ñ–∞–ª–æ–±–∞")]
    ])

@lru_cache(maxsize=1)
def get_back_button():
    return ReplyKeyboardMarkup(resize_keyboard=True, keyboard=[
        [KeyboardButton(text="–ù–∞–∑–∞–¥")]
    ])

class Form(StatesGroup):
    role = State()
    age_verify = State()
    reason = State()
    duration = State()
    complaint = State()

# –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–ª–µ–Ω—Å—Ç–≤–∞
async def is_member(user_id: int) -> bool:
    try:
        member = await bot.get_chat_member(GROUP_ID, user_id)
        return member.status in {"member", "administrator", "creator"}
    except Exception:
        return False

# –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
def check_message_limit(user_id: int) -> bool:
    count = message_counts.get(user_id, 0) + 1
    message_counts[user_id] = count
    return count <= MAX_MESSAGES

# Handlers
@dp.message(F.text.casefold() == "/start")
async def start_handler(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return
    user_id = message.from_user.id
    if not await is_member(user_id) and not check_message_limit(user_id):
        await message.answer("–í—ã –∏—Å—á–µ—Ä–ø–∞–ª–∏ –ª–∏–º–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–π. –í—Å—Ç—É–ø–∏—Ç–µ –≤ –≥—Ä—É–ø–ø—É, —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –æ–±—â–µ–Ω–∏–µ —Å –±–æ—Ç–æ–º. –ï—Å–ª–∏ —ç—Ç–æ –±–∞–≥, –Ω–∞–ø–∏—à–∏—Ç–µ <a href='https://t.me/alren15'>–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É</a>.")
        return

    member = await bot.get_chat_member(GROUP_ID, user_id)
    if member.status in {"member", "administrator", "creator"}:
        await message.answer(" <b>–í—ã —É–∂–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –≥—Ä—É–ø–ø—ã</b>\n\nüéÆ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–Ω—é –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏:", reply_markup=get_menu())
    else:
        await message.answer(
            f''' <b>–ß—Ç–æ –±—ã –≤—Å—Ç—É–ø–∏—Ç—å:</b>\n\nüè† –û–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å <a href='https://telegra.ph/%F0%9D%99%B5%F0%9D%9A%95%F0%9D%9A%98%F0%9D%9A%98%F0%9D%9A%8D-%F0%9D%9A%83%F0%9D%9A%91%F0%9D%9A%8E-%F0%9D%99%BB%F0%9D%9A%98%F0%9D%9A%9D%F0%9D%9A%9E%F0%9D%9A%9C-%F0%9D%9A%9B%F0%9D%9A%9E%F0%9D%9A%95%F0%9D%9A%8E%F0%9D%9A%9C-03-28'>–ø—Ä–∞–≤–∏–ª–∞–º–∏</a>\nüé≠ –í—ã–±–µ—Ä–∏—Ç–µ —Å–≤–æ–±–æ–¥–Ω—É—é —Ä–æ–ª—å –∏–∑ <a href='https://t.me/info_TheLotus/7'>—Å–ø–∏—Å–∫–∞</a>\n\n –ù–∞–ø–∏—à–∏—Ç–µ —Ä–æ–ª—å –±–µ–∑ —Ç–æ—á–∫–∏ –∏ —Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã. –ü—Ä–∏–º–µ—Ä: <b>–ó–µ–ª–µ</b>''',
            disable_web_page_preview=True,
            reply_markup=types.ReplyKeyboardRemove()
        )
        await state.set_state(Form.role)

@dp.message(Form.role)
async def role_handler(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return
    await state.update_data(role=message.text.strip())
    await message.answer('''
–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ —Å–≤–æ–π –≤–æ–∑—Ä–∞—Å—Ç –æ–¥–Ω–∏–º –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤:

   ‚Ä¢ üì∏ –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞
   ‚Ä¢ üé§ –ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
   ‚Ä¢ üé• –í–∏–¥–µ–æ—Å–æ–æ–±—â–µ–Ω–∏–µ
   ‚Ä¢ ‚úçÔ∏è –¢–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ

Ô∏è –ü—Ä–∏ –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏–∏ –æ—à–∏–±–æ–∫ –æ–±—Ä–∞—â–∞–π—Ç–µ—Å—å –∫ <a href='https://t.me/alren15'>–∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É</a>''')
    await state.set_state(Form.age_verify)

@dp.message(Form.age_verify, F.text)
async def age_verify_text_handler(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return
    user_id = message.from_user.id
    data = await state.get_data()
    role = data.get('role')
    user_data[user_id] = {"role": role}

    await message.answer(
        f'–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ <a href="{GROUP_LINK}">—Å—Å—ã–ª–∫–µ</a>. –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –±—É–¥–µ—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∞ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.',
        disable_web_page_preview=True,
        reply_markup=get_menu()
    )

    admin_message = (
        f"üîî <b>–ó–∞—è–≤–∫–∞ –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ!</b>\n\n"
        f"üë§ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: <a href='tg://user?id={user_id}'>{message.from_user.full_name}</a>\n"
        f"üìå –†–æ–ª—å: <b>{role}</b>\n"
        f"‚úçÔ∏è –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ: {message.text}"
    )

    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, admin_message)
    await state.clear()

@dp.message(Form.age_verify)
async def age_verify_any_handler(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return
    user_id = message.from_user.id
    data = await state.get_data()
    role = data.get('role')
    user_data[user_id] = {"role": role}

    await message.answer(
        f'–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ <a href="{GROUP_LINK}">—Å—Å—ã–ª–∫–µ</a>. –í–∞—à–∞ –∑–∞—è–≤–∫–∞ –±—É–¥–µ—Ç —Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–∞ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.',
        disable_web_page_preview=True,
        reply_markup=get_menu()
    )

    admin_message = (
        f"üîî <b>–ó–∞—è–≤–∫–∞ –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏–µ!</b>\n\n"
        f"üë§ –û—Ç: <a href='tg://user?id={user_id}'>{message.from_user.full_name}</a>\n"
        f"üìå –†–æ–ª—å: <b>{role}</b>"
    )

    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, admin_message)
        # –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º –ª—é–±–æ–π —Ç–∏–ø —Å–æ–æ–±—â–µ–Ω–∏—è
        await bot.forward_message(admin_id, message.chat.id, message.message_id)
    await state.clear()

@dp.message(F.text.startswith("?"))
async def photo(message: types.Message):
    user_id = message.from_user.id
    if not await is_member(user_id) and not check_message_limit(user_id):
        await message.answer("–ò–∑–≤–∏–Ω–∏—Ç–µ, –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–æ—Å—å.")
        return
    query = message.text[1:].lower()
    if UNSPLASH_ACCESS_KEY:
        try:
            response = requests.get(f"https://api.unsplash.com/search/photos?query={query}&client_id={UNSPLASH_ACCESS_KEY}")
            response.raise_for_status()
            data = response.json()
            if data['results']:
                random_photo = random.choice(data['results'])
                await bot.send_photo(message.chat.id, random_photo['urls']['regular'])
            else:
                await message.answer("–ò–∑–≤–∏–Ω–∏, –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–æ—Å—å.")
        except requests.exceptions.RequestException as e:
            await message.answer(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ Unsplash: {e}")
        except (KeyError, IndexError) as e:
            await message.answer(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö Unsplash: {e}")
    else:
        await message.answer("API –∫–ª—é—á Unsplash –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")


@dp.message(F.text.lower().startswith("—ç–º–æ–¥–∑–∏"))
async def set_custom_emoji(message: types.Message):
    if message.chat.type not in {ChatType.GROUP, ChatType.SUPERGROUP}:
        return

    user_id = message.from_user.id
    emoji = message.text.split(maxsplit=1)[1].strip() if len(message.text.split()) > 1 else None
    
    if not emoji:
        await message.reply("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–∫–∞–∂–∏—Ç–µ —ç–º–æ–¥–∑–∏ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã.")
        return
        
    if 'user_emojis' not in user_data:
        user_data['user_emojis'] = {}
    
    user_data['user_emojis'][user_id] = emoji
    await message.reply(f"–í–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π —ç–º–æ–¥–∑–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {emoji}")

@dp.message(F.text.casefold().startswith("–∑–∞—Å–æ—Å–∞—Ç—å"))
async def kiss_handler(message: types.Message):
    if message.chat.type not in {ChatType.GROUP, ChatType.SUPERGROUP}:
        return

    if not message.reply_to_message:
        return

    sender = message.from_user
    target = message.reply_to_message.from_user

    if target.is_bot:
        return

    kiss_message = f"üíã | <a href='tg://user?id={sender.id}'>{sender.full_name}</a> –∂—ë—Å—Ç–∫–æ –∑–∞—Å–æ—Å–∞–ª <a href='tg://user?id={target.id}'>{target.full_name}</a>"
    await message.answer(kiss_message)

@dp.message(F.text == "–†–µ—Å—Ç")
async def request_rest(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return  
    user_id = message.from_user.id
    if not await is_member(user_id):
        await message.answer("–í—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º.", reply_markup=get_menu())
        return
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É —Ä–µ—Å—Ç–∞:", reply_markup=get_back_button())
    await state.set_state(Form.reason)

@dp.message(Form.reason)
async def rest_reason(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return  
    if message.text == "–ù–∞–∑–∞–¥":
        await back_to_menu(message, state)
        return
    await state.update_data(reason=message.text)
    await message.answer("–ù–∞–ø–∏—à–∏—Ç–µ —Å—Ä–æ–∫ —Ä–µ—Å—Ç–∞:")
    await state.set_state(Form.duration)

@dp.message(Form.duration)
async def rest_duration(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return  
    if message.text == "–ù–∞–∑–∞–¥":
        await state.set_state(Form.reason)
        await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–ø–∏—à–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É —Ä–µ—Å—Ç–∞ –∑–∞–Ω–æ–≤–æ:", reply_markup=get_back_button())
        return
    data = await state.get_data()
    role = await bot.get_chat_member(GROUP_ID, message.from_user.id)
    admin_message = f'''üîî <b>–ó–∞—è–≤–∫–∞ –Ω–∞ —Ä–µ—Å—Ç</b>
üìå –†–æ–ª—å: {role.custom_title if role.custom_title else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}
‚öôÔ∏è –ü—Ä–∏—á–∏–Ω–∞: {data['reason']}
‚åõÔ∏è –°—Ä–æ–∫: {message.text}'''
    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, admin_message)
    await message.answer("–í—ã –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –∑–∞—è–≤–∫—É.", reply_markup=get_menu())
    await state.clear()

@dp.message(F.text == "–ñ–∞–ª–æ–±–∞")
async def complaint(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return  
    user_id = message.from_user.id
    if not await is_member(user_id):
        await message.answer("–í—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º.", reply_markup=get_menu())
        return
    await message.answer("–û–ø–∏—à–∏—Ç–µ –≤–∞—à—É –∂–∞–ª–æ–±—É:", reply_markup=get_back_button())
    await state.set_state(Form.complaint)

@dp.message(Form.complaint)
async def handle_complaint(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return  
    if message.text == "–ù–∞–∑–∞–¥":
        await back_to_menu(message, state)
        return
    for admin_id in ADMIN_IDS:
        await bot.send_message(admin_id, f'''üîî <b>–ù–æ–≤–∞—è –∂–∞–ª–æ–±–∞ –æ—Ç</b> {message.from_user.full_name}:
{message.text}''')
    await message.answer("–í—ã –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –∂–∞–ª–æ–±—É.", reply_markup=get_menu())
    await state.clear()

@dp.message(F.text == "–ù–∞–∑–∞–¥")
async def back_to_menu(message: types.Message, state: FSMContext):
    if message.chat.type != ChatType.PRIVATE:
        return  
    await message.answer("–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –º–µ–Ω—é.", reply_markup=get_menu())
    await state.clear()

@dp.chat_member()
async def chat_member_handler(update: types.ChatMemberUpdated):
    chat_id = update.chat.id
    if chat_id != GROUP_ID:
        return

    old_status = update.old_chat_member.status if update.old_chat_member else None
    new_status = update.new_chat_member.status if update.new_chat_member else None
    user_id = update.new_chat_member.user.id

    logging.info(f"–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞: {old_status} -> {new_status} –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—ã—Ö–æ–¥ —É—á–∞—Å—Ç–Ω–∏–∫–∞
    if old_status == "member" and new_status == "left":
        if user_id in user_data:
            custom_title = user_data[user_id].get("custom_title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
            leave_message = f"üò¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å <a href='tg://user?id={user_id}'>{update.new_chat_member.user.full_name}</a> —Å —Ä–æ–ª—å—é <b>{custom_title}</b> –ø–æ–∫–∏–Ω—É–ª –≥—Ä—É–ø–ø—É"
            await bot.send_message(chat_id, leave_message)

            admin_message = f'''üëã <b>–£—á–∞—Å—Ç–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª –≥—Ä—É–ø–ø—É</b>\n\nüò¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: <a href='tg://user?id={user_id}'>{update.new_chat_member.user.full_name}</a>\nüé≠ –†–æ–ª—å: <b>{custom_title}</b>'''
            for admin_id in ADMIN_IDS:
                await bot.send_message(admin_id, admin_message)

            if 'user_emojis' in user_data and user_id in user_data['user_emojis']:
                del user_data['user_emojis'][user_id]
            user_data.pop(user_id, None)
            return

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø—É
    if new_status == "member" and user_id in user_data and not update.new_chat_member.user.is_bot:
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –±–æ—Ç–∞
            bot_member = await bot.get_chat_member(chat_id, (await bot.me()).id)
            if not bot_member.can_promote_members:
                logging.error(f"–ë–æ—Ç –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –≤ –≥—Ä—É–ø–ø–µ {chat_id}")
                for admin_id in ADMIN_IDS:
                    await bot.send_message(admin_id, f"‚ö†Ô∏è –ë–æ—Ç –Ω–µ –∏–º–µ–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –≤ –≥—Ä—É–ø–ø–µ {chat_id}")
                return

            role = user_data[user_id]["role"]
            await bot.promote_chat_member(chat_id, user_id, 
                can_change_info=False,
                can_delete_messages=False,
                can_invite_users=False,
                can_restrict_members=False,
                can_pin_messages=True,
                can_promote_members=False
            )
            await bot.set_chat_administrator_custom_title(chat_id, user_id, role)
            user_data[user_id]["custom_title"] = role

            members = await bot.get_chat_administrators(chat_id)
            members.extend([await bot.get_chat_member(chat_id, member_id) for member_id in [m.user.id for m in members]])
            tags = []
            emojis = ["‚≠êÔ∏è", "üåü", "üí´", "‚ö°Ô∏è", "üî•", "‚ù§Ô∏è", "üíû", "üíï", "‚ù£Ô∏è", "üíå", "üåà", "‚ú®", "üéØ", "üé™", "üé®", "üé≠", "üé™", "üé¢", "üé°", "üé†", "üé™", "üå∏", "üå∫", "üå∑", "üåπ", "üåª", "üåº", "üíê", "üåæ", "üåø", "‚òòÔ∏è", "üçÄ", "üçÅ", "üçÇ", "üçÉ", "üåµ", "üå¥", "üå≥", "üå≤", "üéÑ", "üåä", "üåà", "‚òÄÔ∏è", "üå§", "‚õÖÔ∏è", "‚òÅÔ∏è", "üå¶", "üå®", "‚ùÑÔ∏è", "‚òÉÔ∏è",  "üå¨", "üí®", "üå™", "üå´", "üåà", "‚òîÔ∏è", "‚ö°Ô∏è", "‚ùÑÔ∏è", "üîÆ", "üéÆ", "üé≤", "üéØ", "üé≥", "üé™", "üé≠", "üé®", "üé¨", "üé§", "üéß", "üéº", "üéπ", "ü•Å", "üé∑", "üé∫", "üé∏", "ü™ï", "üéª", "üé≤", "‚ôü", "üéØ", "üé≥", "üéÆ", "üé∞", "üß©", "üé™", "üé≠", "üé®", "üñº", "üé®", "üßµ", "üß∂", "üëë", "üíé", "‚öúÔ∏è"]

            # –°–æ–∑–¥–∞–µ–º –∏–ª–∏ –ø–æ–ª—É—á–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —ç–º–æ–¥–∑–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            if 'user_emojis' not in user_data:
                user_data['user_emojis'] = {}

            # –ù–∞–∑–Ω–∞—á–∞–µ–º —ç–º–æ–¥–∑–∏ –Ω–æ–≤–æ–º—É —É—á–∞—Å—Ç–Ω–∏–∫—É
            if user_id not in user_data['user_emojis']:
                available_emojis = [e for e in emojis if e not in user_data['user_emojis'].values()]
                if available_emojis:
                    user_data['user_emojis'][user_id] = random.choice(available_emojis)

            for member in members:
                if not member.user.is_bot:
                    member_id = member.user.id
                    if member_id not in user_data['user_emojis']:
                        available_emojis = [e for e in emojis if e not in user_data['user_emojis'].values()]
                        if available_emojis:
                            user_data['user_emojis'][member_id] = random.choice(available_emojis)

                    emoji = user_data['user_emojis'].get(member_id, "üë§")
                    tag = f"<a href='tg://user?id={member_id}'>{emoji}</a>"
                    tags.append(tag)
            # –†–∞–∑–±–∏–≤–∞–µ–º —Ç–µ–≥–∏ –Ω–∞ –≥—Ä—É–ø–ø—ã –ø–æ 10
            tag_chunks = [tags[i:i + 10] for i in range(0, len(tags), 10)]
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –Ω–æ–≤–æ–º —É—á–∞—Å—Ç–Ω–∏–∫–µ
            first_chunk = " ".join(tag_chunks[0]) if tag_chunks else ""
            await bot.send_message(
                chat_id,
                f'''üì¢ –ù–æ–≤—ã–π —É—á–∞—Å—Ç–Ω–∏–∫: <a href='tg://user?id={update.new_chat_member.user.id}'>{update.new_chat_member.user.full_name}</a>
üé≠ –†–æ–ª—å: <b>{role}</b>
{first_chunk}'''
            )
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —á–∞–Ω–∫–∏ —ç–º–æ–¥–∑–∏
            for chunk in tag_chunks[1:]:
                chunk_text = " ".join(chunk)
                await bot.send_message(chat_id, chunk_text)
            await bot.send_message(user_id, f'''üåü <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!</b> 
–í–∞—à–∞ –∑–∞—è–≤–∫–∞ –æ–¥–æ–±—Ä–µ–Ω–∞. –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å —Å –º–µ–Ω—é.''', reply_markup=get_menu())
        except Exception as e:
            logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ —Ä–æ–ª–∏: {e}")
            for admin_id in ADMIN_IDS:
                await bot.send_message(admin_id, f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏–∏ —Ä–æ–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {update.new_chat_member.user.full_name}: {str(e)}")
    elif update.new_chat_member.status in {"left", "kicked"}:
        if user_id in user_data:
            custom_title = user_data[user_id].get("custom_title", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ")
            notify_user_id = os.environ.get('NOTIFY_USER_ID')
            mention_text = f"<a href='tg://user?id={notify_user_id}'>üë§</a>" if notify_user_id else ""
            leave_message = f"üò¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å <a href='tg://user?id={user_id}'>{update.new_chat_member.user.full_name}</a> —Å —Ä–æ–ª—å—é <b>{custom_title}</b> –ø–æ–∫–∏–Ω—É–ª –≥—Ä—É–ø–ø—É\n{mention_text}"
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É
            await bot.send_message(chat_id, leave_message)
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∞–º
            admin_message = f'''üëã <b>–£—á–∞—Å—Ç–Ω–∏–∫ –ø–æ–∫–∏–Ω—É–ª –≥—Ä—É–ø–ø—É</b>
üò¢ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: <a href='tg://user?id={user_id}'>{update.new_chat_member.user.full_name}</a>
üé≠ –†–æ–ª—å: <b>{custom_title}</b>'''
            for admin_id in ADMIN_IDS:
                await bot.send_message(admin_id, admin_message)
            # –£–¥–∞–ª—è–µ–º —ç–º–æ–¥–∑–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
            if 'user_emojis' in user_data and user_id in user_data['user_emojis']:
                del user_data['user_emojis'][user_id]
            user_data.pop(user_id, None)

# –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫
async def save_existing_members_titles():
    try:
        chat = await bot.get_chat(GROUP_ID)
        members = await bot.get_chat_administrators(GROUP_ID)
        for member in members:
            if member.custom_title and member.user.id not in user_data:
                user_data[member.user.id] = {
                    "role": member.custom_title,
                    "custom_title": member.custom_title
                }
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ç–∏—Ç—É–ª–æ–≤: {e}")

async def main():
    try:
        # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        await save_existing_members_titles()
        logging.info("Bot started")
        await dp.start_polling(bot, allowed_updates=["message", "chat_member"])
    except Exception as e:
        logging.error(f"Error: {e}")
        raise

if __name__ == "__main__":
    asyncio.run(main())
